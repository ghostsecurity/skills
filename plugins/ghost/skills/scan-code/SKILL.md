---
name: scan-code
description: |
  Ghost Security - Static application security testing (SAST) scanner.
  Runs a multi-phase analysis pipeline that performs a code security vulnerability analysis.
  Supports full-repo scans and commit-diff scans.
  Use when the user wants to scan code with ghost for security issues, find vulnerabilities, run security analysis, or review a codebase for risks.
allowed-tools: Read, Glob, Grep, Bash, Task, TodoRead, TodoWrite, TaskCreate, TaskUpdate, TaskGet, TaskList
argument-hint: "[provided-extra-details]"
context: fork
model: sonnet
disable-model-invocation: false
user-invocable: true
---

# Overview - Ghost Security Code Scanner

This skill follows a phased, step by step methodology for understanding a codebase's structure, dynamically deciding what to scan for, and carrying out a thorough finding discovery analysis with finding verification.


## Defaults

These defaults apply unless overridden by user/agent arguments below.

- **repo_path**: the current working directory
- **cache_dir**: `.ghost/cache` — global, repo-level cache (reused across scans). Holds codebase metadata.
- **scan_dir**: `.ghost/scans/<scan_id>` — per-scan working directory. Holds the scan plan, findings, and final report for a single scan run.
- **scan_id**: compact timestamp generated by the orchestrator at the start of each run, formatted as `YYYYMMDD-HHMMSS` (e.g., `20260205-203000`). Can be overridden via arguments.

The orchestrator passes only the path prefixes each subagent needs. The context subagent only needs `repo_path` and `cache_dir`. All other subagents need `repo_path`, `cache_dir`, and `scan_dir`.

## User or Agent Provided Extra Details

Any values here override the defaults above.

$ARGUMENTS

---

## Task Definition Rules

- Each phase must be completed according to the defined order
- Use your task tracking capability to organize the work
- Each phase is meant to be run by a dedicated subagent with its own context window
- Each phase will report back with one or more file/directory paths as its output
- Update the task list as phases are completed

## Orchestrator: How to Run Each Step

For each step in the workflow:

1. **Dispatch**: Spawn a subagent with a prompt that tells it to read its agent file and provides the path prefixes it needs. Use your agent/subagent spawning capability — do NOT use Bash, shell commands, or file writes to build prompts. The context agent only needs `repo_path` and `cache_dir`. All other agents also need `scan_dir`. For example:

   > Read and follow the instructions in agents/plan/agent.md.
   >
   > ## Inputs
   > - repo_path: <repo_path>
   > - cache_dir: .ghost/cache
   > - scan_dir: .ghost/scans/<scan_id>

2. **Confirm completion**: Every subagent will end its response with a structured `## Outputs` block. Verify the step completed successfully before moving to the next step.

### Error Handling

If a subagent fails or returns an error instead of a valid `## Outputs` block:
- Retry the step **once** with the same inputs.
- If it fails again, **stop the workflow** and report the failure to the user, including which step failed and the subagent's error output.

## Scan Workflow

Track your progress:

Scan Progress Task Tracking:
- [ ] Step 1: Delegate to a Subagent: Gather codebase **context**
- [ ] Step 2: Delegate to a Subagent: Determine what to **scan** (depends on step 1)
- [ ] Step 3: Delegate to a Subagent: Perform **analysis** (depends on step 2)
- [ ] Step 4: Delegate to a Subagent: Create structured **summary** (depends on step 3)

## Steps Index

**Step 1: Gather codebase context**

Depends On: None
Task: Dispatch a subagent — tell it to read and follow [agents/context/agent.md](agents/context/agent.md)
Inputs: `repo_path`, `cache_dir`
Writes output to: `<cache_dir>/repo.md`

**Step 2: Determine what to scan**

Depends On: Step 1 must successfully complete to proceed
Task: Dispatch a subagent — tell it to read and follow [agents/plan/agent.md](agents/plan/agent.md)
Inputs: `repo_path`, `cache_dir`, `scan_dir`, `base_commit` (optional), `head_commit` (optional)
Reads from: `<cache_dir>/repo.md`
Writes output to: `<scan_dir>/plan.md`
Note: By default this is a fresh scan (no commit args). If `base_commit` and `head_commit` are provided in `$ARGUMENTS`, pass them through to the plan subagent to perform an incremental diff scan. Example dispatch:

> Read and follow the instructions in agents/plan/agent.md.
>
> ## Inputs
> - repo_path: <repo_path>
> - cache_dir: .ghost/cache
> - scan_dir: .ghost/scans/<scan_id>
> - base_commit: <base_commit>
> - head_commit: <head_commit>

**Step 3: Perform Analysis**

Depends On: Step 2 must successfully complete to proceed
Task: Dispatch a subagent — tell it to read and follow [agents/analysis/agent.md](agents/analysis/agent.md)
Inputs: `repo_path`, `cache_dir`, `scan_dir`
Reads from: `<cache_dir>/repo.md`, `<scan_dir>/plan.md`
Writes output to: `<scan_dir>/findings/`

**Step 4: Create structured summary**

Depends On: Step 3 must successfully complete to proceed
Task: Dispatch a subagent — tell it to read and follow [agents/summary/agent.md](agents/summary/agent.md)
Inputs: `repo_path`, `cache_dir`, `scan_dir`
Reads from: `<cache_dir>/repo.md`, `<scan_dir>/plan.md`, `<scan_dir>/findings/`
Writes output to: `<scan_dir>/report.md`
